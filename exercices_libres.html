<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
</head>
<body>
<h1 id="semaine1">Semaine 1</h1>

<p>Nous vous proposons cette semaine quelques exercices sur l’électronique. L’introduction au langage <em>C</em> se fera la semaine prochaine. Vous pouvez déjà faire quelques pas en programmation en suivant le premier volet de nos exercices :</p>

<ul>
<li>Pour <em>Arduino</em> : <a href="http://www.didel.com/coursera/LC1.pdf">LC1.pdf</a></li>
<li>Pour <em>Energia/MSP430</em> : <a href="http://pyr.ch/coursera/LC1-msp.pdf">LC1-msp.pdf</a></li>
</ul>

<p>Le devoir de programmation de la semaine vous demande de montrer que vous avez un environnement <em>Arduino</em> ou <em>Energia</em> opérationnel. Toutes les indications se trouvent dans la page “Devoirs de programmation”, en cliquant sur “View instructions”.</p>

<p>Voici donc quelques exercices sur l’électronique. Nous sommes conscients qu’ils seront trop difficiles pour ceux qui n’ont aucune connaissance préalable en électronique et qu’ils seront trop simples pour ceux qui sont déjà électroniciens. Nous espérons qu’ils seront malgré tout utiles à certains. Mais la maîtrise de ces exercices n’est pas nécessaire pour la suite du MOOC !</p>

<p><a href="http:///www.pyr.ch/Coursera/EnW1FreeEx.pdf">English translation</a></p>

<h2 id="ex1.2-1détecteurdegel"><em>Ex 1.2&#8211;1</em> Détecteur de gel</h2>

<p>Le montage suivant, alimenté en 5 V, permet de réaliser un détecteur de gel :</p>

<figure>
<img src="images/transistor-ctn.png" alt="transistor-ctn" />
<figcaption>transistor-ctn</figcaption>
</figure>

<p>Il utilise une thermistance. Ce composant a une résistance variable en fonction de la température. Un transistor est utilisé pour amplifier le signal de la thermistance. Il est utilisé en “tout ou rien” : tant que la résistance est trop élevée pour que le transistor conduise, la LED est éteinte. Mais dès que la thermistance atteint une résistance suffisamment faible pour que la tension de seuil du transistor soit atteinte, le transistor va conduire et la LED s’allumer.</p>

<p>On considère que le transistor a un gain important et qu’on peut donc négliger le courant de base dans les calculs. Le composant noté <em>CTN</em> est une thermistance dont le coefficient de température est négatif. Sa résistance (donnée en kΩ) varie avec la température selon la courbe suivante :</p>

<figure>
<img src="images/thermistance.gif" alt="thermistance" />
<figcaption>thermistance</figcaption>
</figure>

<p><strong>Question :</strong> Quelle valeur doit-on donner à la résistance R pour que le détecteur avertisse du risque de gel vers 1°C ?</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex1-2-1">Corrigé</a> !</p>

<h2 id="ex1.3-1logiqueàtransistors"><em>Ex 1.3&#8211;1</em> Logique à transistors</h2>

<p><strong>Question :</strong> Quelle est la fonction logique réalisée par ce montage ?</p>

<figure>
<img src="images/D3q1.gif" alt="D3q1" />
<figcaption>D3q1</figcaption>
</figure>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex1-3-1">Corrigé</a> !</p>

<h2 id="ex1.4-1schémaduou-exclusif"><em>Ex 1.4&#8211;1</em> Schéma du OU-exclusif</h2>

<p>Voici la table de vérité de la fonction OU-exclusif :</p>

<table>
<colgroup>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:left;">A</th>
	<th style="text-align:left;">B</th>
	<th style="text-align:left;">S</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;">0</td>
	<td style="text-align:left;">0</td>
	<td style="text-align:left;">0</td>
</tr>
<tr>
	<td style="text-align:left;">0</td>
	<td style="text-align:left;">1</td>
	<td style="text-align:left;">1</td>
</tr>
<tr>
	<td style="text-align:left;">1</td>
	<td style="text-align:left;">0</td>
	<td style="text-align:left;">1</td>
</tr>
<tr>
	<td style="text-align:left;">1</td>
	<td style="text-align:left;">1</td>
	<td style="text-align:left;">0</td>
</tr>
</tbody>
</table>

<p><strong>Question :</strong> Dessinez le schéma logique correspondant.</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex1-4-1">Corrigé</a> !</p>

<h2 id="ex1.4-2diagrammetemporel"><em>Ex 1.4&#8211;2</em> Diagramme temporel</h2>

<p><strong>Question :</strong> Donnez la table de vérité du système combinatoire décrit par ce diagramme temporel.</p>

<figure>
<img src="images/diagramme-temp-ex.png" alt="diagramme-temp-ex" />
<figcaption>diagramme-temp-ex</figcaption>
</figure>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex1-4-2">Corrigé</a> !</p>

<h2 id="ex1.5-1machined’état"><em>Ex 1.5&#8211;1</em> Machine d’état</h2>

<p><strong>Question :</strong> Étudiez la réalisation d’un compteur-décompteur par 5. Vous pouvez successivement :</p>

<ul>
<li>dessiner le schéma-bloc du système, avec ses entrées et ses sorties</li>
<li>dessiner le graphe d’état</li>
<li>réfléchir au nombre de bascules nécessaires</li>
<li>dessiner et remplir la table de vérité du système combinatoire</li>
<li>écrire les équations du système combinatoire.</li>
</ul>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex1-5-1">Corrigé</a> !</p>

<h2 id="ex1.6-1conversiondécimal-binaire"><em>Ex 1.6&#8211;1</em> Conversion décimal-binaire</h2>

<p><strong>Question :</strong> Convertissez en binaire les nombres décimaux suivants : <code>5</code>, <code>12</code>, <code>63</code>, <code>257</code>, <code>1280</code></p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex1-6-1">Corrigé</a> !</p>

<h2 id="ex1.6-2conversionbinaire-hexadécimal"><em>Ex 1.6&#8211;2</em> Conversion binaire-Hexadécimal</h2>

<p><strong>Question :</strong> Convertissez en hexadécimal les nombres binaires suivants : <code>0b00110111</code>, <code>0b01011111</code>, <code>0b1110010011011001</code>, <code>0b101111001</code></p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex1-6-2">Corrigé</a> !</p>

<h2 id="ex1.6-3conversionbcd-décimal"><em>Ex 1.6&#8211;3</em> Conversion BCD-décimal</h2>

<p><strong>Question :</strong> Convertissez en décimal les nombres BCD suivants : <code>0010001101011001</code> et <code>1110010011011001</code></p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex1-6-3">Corrigé</a> !</p>

<h1 id="semaine2">Semaine 2</h1>

<p>Vous trouvez ci-dessous des exercices libres. Comme le passage des vidéos à ces exercices a été jugé trop brutal, décourageant plusieurs étudiants, nous avons été amenés à écrire une série de documents détaillant les notions essentielles et s’appuyant sur des exemples progressifs à vérifier avec du matériel, le <em>LearnCbot</em> (ou un câblage équivalent sur <em>breadboard</em>, décrit dans la dernière vidéo). La semaine dernière, nous vous avions déjà proposé :</p>

<ul>
<li>pour <em>Arduino/Diduino</em> : <a href="http://didel.com/coursera/LC1.pdf">LC1.pdf</a></li>
<li>pour <em>Energia/MSP430</em> : <a href="http://pyr.ch/coursera/LC1-msp.pdf">LC1-msp.pdf</a></li>
</ul>

<p>Assurez-vous d’avoir compris le premier document ! Vous êtes encouragés cette semaine à travailler avec le second document :</p>

<ul>
<li>pour <em>Arduino/Diduino</em> : <a href="http://didel.com/coursera/LC2.pdf">LC2.pdf</a></li>
<li>pour <em>Energia/MSP430</em> : <a href="http://pyr.ch/coursera/LC2-msp.pdf">LC2-msp.pdf</a></li>
</ul>

<h2 id="ex2.2-1microprocesseuretmicrocontrôleur"><em>Ex 2.2&#8211;1</em> Microprocesseur et microcontrôleur</h2>

<p><strong>Question :</strong> Quelle est la différence entre un microcontrôleur et un microprocesseur ?</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex2-2-1">Corrigé</a> !</p>

<h2 id="ex2.3-1microcontrôleurs8-16-32 bits"><em>Ex 2.3&#8211;1</em> Microcontrôleurs 8&#8211;16&#8211;32 bits</h2>

<p>Dans une application qui nécessite une bonne précision de calcul, on doit effectuer plusieurs fois par seconde quelques calculs arithmétiques avec des nombres de 32 bits.</p>

<p><strong>Question :</strong> Est-ce qu’on est obligé alors de choisir un microcontrôleur 32 bits ?</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex2-3-1">Corrigé</a> !</p>

<h2 id="ex2.3-2fréquenceetpuissancedecalcul"><em>Ex 2.3&#8211;2</em> Fréquence et puissance de calcul</h2>

<p><strong>Question :</strong> Si la fréquence d’un microcontrôleur est supérieure à celle d’un autre microcontrôleur, peut-on dire alors que sa puissance de calcul est supérieure ?</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex2-3-2">Corrigé</a> !</p>

<h2 id="ex2.4-1programmationencarduino :clignoterpendantquel’onpresse"><em>Ex 2.4&#8211;1</em> Programmation en <em>C/Arduino</em> : clignoter pendant que l’on presse</h2>

<p>Un poussoir actif à <em>0</em> est câblé sur la pin 4. Une LED sur la pin 5. Si on presse (statique), la LED doit clignoter à 2 Hz (période 500 ms).</p>

<p>Cherchez par vous-même à écrire le programme. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex2-4-1">Corrigé</a> !</p>

<h2 id="ex2.4-2programmationencarduino :allumer2 squandonpresse"><em>Ex 2.4&#8211;2</em> Programmation en <em>C/Arduino</em> : allumer 2 s quand on presse</h2>

<p>Si on presse (dynamique), le programme doit allumer la LED pendant 2 s. Tester en pressant plus ou moins vite.</p>

<p>Cherchez par vous-même à écrire le programme. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex2-4-2">Corrigé</a> !</p>

<h2 id="ex2.4-3programmationencarduino :unpoussoirpour2leds"><em>Ex 2.4&#8211;3</em> Programmation en <em>C/Arduino</em> : Un poussoir pour 2 LEDs</h2>

<p>On a un poussoir et deux LEDs. Le poussoir a une action quand on presse. Si on presse, la LED 1 change d’état. Si on presse et seulement si la LED 1 est allumée, la LED 2 change d’état.</p>

<p>Écrire le programme et dire ce que l’on a programmé.</p>

<p>Cherchez par vous-même à écrire le programme. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex2-4-3">Corrigé</a> !</p>

<h2 id="ex2.4-4programmationencarduino :deuxpoussoirspouruneled"><em>Ex 2.4&#8211;4</em> Programmation en <em>C/Arduino</em> : Deux poussoirs pour une LED</h2>

<p>Le poussoir <code>Pous1</code> doit allumer la LED. Le poussoir <code>Pous2</code> doit l’éteindre. On va reconnaître la bascule RS.</p>

<p>Cherchez par vous-même à écrire le programme. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex2-4-4">Corrigé</a> !</p>

<h2 id="ex2.5-1programmationd’uncompteurupdown"><em>Ex 2.5&#8211;1</em> Programmation d’un compteur up/down</h2>

<p>On a une variable <code>byte compteur;</code> dont on va modifier la valeur avec deux poussoirs qui agissent statiquement. On ne sait pas encore comment afficher cette valeur, mais pour avoir une idée, on allume la LED pour les valeurs impaires. Un clignotement de la LED indique que le compteur augmente ou diminue (rajouter des LEDs si vous voulez).</p>

<p>Quand on pèse sur <code>Pous1</code> et on maintien pressé (action statique), le compteur augmente chaque 0.2 s, mais se bloque à 7, LED allumée puisque c’est impair.</p>

<p>Quand on pèse sur <code>Pous1</code> et maintien pressé, le compteur décompte et se bloque à <em>0</em>, LED éteinte.</p>

<p>Cherchez par vous-même à écrire le programme. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex2-5-1">Corrigé</a> !</p>

<h2 id="ex2.5-2estimationdeladuréedelafonctionarduinomap"><em>Ex 2.5&#8211;2</em> Estimation de la durée de la fonction <em>Arduino</em> <code>Map()</code></h2>

<p>La fonction <em>Arduino</em> <code>map()</code> doit faire des multiplications et divisions. Quel est son temps de calcul ?</p>

<p>On met cette fonction dans une boucle exécutée 10’000 fois (max 30000 en 16 bits signés). On mesure la période entre deux basculements de la LED. Si la fonction dure 100 µs, la période est de 1 s. Écrire le programme et dire quelle est la durée de la fonction <code>map()</code>.</p>

<p>Cherchez par vous-même à écrire le programme. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex2-5-2">Corrigé</a> !</p>

<h1 id="semaine3">Semaine 3</h1>

<p>Vous trouvez ci-dessous des exercices libres qui ont été proposés pour notre premier MOOC en octobre 2013. Ils complètent notre suite d’exemples et exercices à tester avec le <em>LearnCbot</em> ou un câblage équivalent. Voici les fichiers de la semaine :</p>

<ul>
<li>pour <em>Arduino</em> : <a href="http://www.didel.com/coursera/LC3.pdf">LC3.pdf</a></li>
<li>pour <em>Energia/MSP430</em> : <a href="http://pyr.ch/coursera/LC3-msp.pdf">LC3-msp.pdf</a></li>
</ul>

<p>Ces documents doivent être lus attentivement pour se familiariser avec la richesse du <em>C</em>.</p>

<p>Les programmes sont disponibles sous forme de fichier zip :</p>

<ul>
<li>pour <em>Arduino</em> : <a href="http://www.didel.com/coursera/LC3ino.zip">LC3ino.zip</a></li>
<li>pour <em>Energia/MSP430</em> : <a href="http://pyr.ch/coursera/LC3msp.zip">LC3msp.zip</a></li>
</ul>

<p>Ils vous permettent de passer plus de temps sur leur lecture et vos essais de modification. Prenez plaisir à vos progrès !</p>

<h2 id="ex3.1-1variablesetarithmétique"><em>Ex 3.1&#8211;1</em> Variables et arithmétique</h2>

<p>Nous avons les variables suivantes :</p>

<pre><code>byte x=8; byte y=3; byte z=250;
</code></pre>

<p>Rappels:</p>

<ul>
<li>le type <code>byte</code> (ou <code>unsigned char</code>) est un nombre entier de 8 bits, capable de prendre des valeurs de <em>0</em> à <em>255</em>.</li>
<li>l’opération <code>/</code> est la division entière</li>
<li>l’opération % est le reste de la division entière</li>
</ul>

<p><strong>Question :</strong> Calculez :</p>

<ol>
<li><code>x + y</code></li>
<li><code>y + z</code></li>
<li><code>x + z</code></li>
<li><code>y - x</code></li>
<li><code>x / y</code></li>
<li><code>y / x</code></li>
<li><code>z / y</code></li>
<li><code>z % y</code></li>
</ol>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex3-1-1">Corrigé</a> !</p>

<h2 id="ex3.1-2autremanièred’écrirelabouclefor"><em>Ex 3.1&#8211;2</em> Autre manière d’écrire la boucle <code>for</code></h2>

<p>Quand on écrit une boucle : <code>for (i=0; i&lt;10; i++) {instructions}</code> on passe trois paramètres au compilateur :</p>

<ol>
<li>l’instruction d’initialisation (ici <code>i=0;</code>) : cette instruction qui va s’exécuter une et une seule fois au début</li>
<li>la condition d’exécution de la boucle (ici <code>i&lt;10;</code>) : un test, répété à chaque début de boucle, qui permet de savoir si elle doit s’exécuter (ou s’arrêter)</li>
<li>l’instruction “d’incrémentation” (ici <code>i++</code>) : ce terme est inexact. Il s’agit souvent d’une incrémentation, mais c’est simplement une instruction qui s’exécute à la fin de chaque itération de la boucle.</li>
</ol>

<p>Écrivez cette même action sans le mot <code>for</code> !</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex3-1-2">Corrigé</a> !</p>

<h2 id="ex3.1-3utilisationdel’instructionbreak"><em>Ex 3.1&#8211;3</em> Utilisation de l’instruction <code>break</code></h2>

<p>L’instruction <code>break;</code> permet de sortir d’un <code>{ bloc d’instructions }</code> avant sa fin. Il est souvent utilisé comme une sortie “en catastrophe”. Par exemple, on peut lancer un clignotement dans une boucle <code>while()</code> et en sortir avec un break; après le 3e clignotement :</p>

<pre><code>// extrait du programme Solution310.ino
byte i=0;
while (1)
  Led1On; delay (500);
  Led1Off; delay (500);
  if (i &gt;= 3) { break; }
  i++;
}
delay (1000); // on continue avec d’autres
              // instructions ou on
              // recommence dans
              // la boucle principale.
</code></pre>

<p><strong>Question :</strong> Écrire un programme qui attend une pression sur <code>Pous1</code> et sort de l’attente en clignotant si on ne presse pas dans les 5 s. On doit donc presser régulièrement pour réinitialiser un compteur qui augmente avec une période de 50 ms.</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex3-1-3">Corrigé</a> !</p>

<h2 id="ex3.2-1testdetouslesportsd’unmicrocontrôleur"><em>Ex 3.2&#8211;1</em> Test de tous les ports d’un microcontrôleur</h2>

<p>Écrivez un programme qui teste toutes les sorties d’un microcontrôleur en les faisant clignoter : tous les bits pairs allumés, puis tous les bits impairs.</p>

<p>Écrivez-le pour un <em>AVR</em> ou un <em>MSP430G</em>.</p>

<p>Rappels :</p>

<ul>
<li>Le microcontrôleur <em>ATmega328</em> de l’<em>Arduino</em> dispose des ports <code>B</code>, <code>C</code> et <code>D</code>. Les bits pairs sont <code>PB0</code>, <code>PB2</code>, <code>PB4</code>, &#8230;, <code>PC0</code>, <code>PC2</code>,&#8230; et les bits impairs <code>PB1</code>, <code>PB3</code>,&#8230;, <code>PC1</code>, <code>PC3</code>&#8230; Les registres de direction s’appellent <code>DDR</code> (<code>DDRB</code>, <code>DDRC</code>, etc.) et les registres de sortie s’appellent <code>PORT</code> (<code>PORTB</code>, <code>PORTC</code>, etc.)</li>
<li>Le microcontrôleur <em>MSP430G2553</em> du <em>LaunchPad</em> dispose des ports <code>P1</code> et <code>P2</code>. Les registres de direction s’appellent <code>P1DIR</code> (et <code>P2DIR</code>) et les registres de sortie s’appellent <code>P1OUT</code> (et <code>P2OUT</code>).</li>
</ul>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex3-2-1">Corrigé</a> !</p>

<h2 id="ex3.2-2charlieplexing"><em>Ex 3.2&#8211;2</em> <em>Charlieplexing</em></h2>

<p>Comment faire lorsqu’on a 6 LEDs, qu’on doit pouvoir en allumer une parmi les 6 et qu’on ne dispose que de 3 pattes sur un microcontrôleur ?</p>

<p>Il existe une solution astucieuse, connue sous le nom de _Charlieplexing_ !</p>

<p>Voici le schéma :</p>

<figure>
<img src="images/charlieplexing-3.png" alt="charlieplexing-3" />
<figcaption>charlieplexing&#8211;3</figcaption>
</figure>

<p>Écrivez les deux instructions qui allument la LED 5 sans en allumer d’autres.</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex3-2-2">Corrigé</a> !</p>

<h2 id="ex3.3-1champsdebits"><em>Ex 3.3&#8211;1</em> Champs de bits</h2>

<p>Écrivez d’une manière plus lisible l’instruction suivante : <code>DDRC = 0b01000001;</code></p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex3-3-1">Corrigé</a> !</p>

<h2 id="ex3.4-1combiende1 "><em>Ex 3.4&#8211;1</em> Combien de 1 ?</h2>

<p>On doit compter le nombre de <em>1</em> dans un mot de 16 bits. L’algorithme consiste à tester si le bit en extrémité vaut <em>1</em> ou <em>0</em>, puis à décaler.</p>

<p>Indiquez le résultat par des clignotements. Tester des données en :</p>

<ul>
<li>binaire : <code>mot= 0b0000 1000 0100 1100;</code> résultat <code>4</code></li>
<li>hexadécimal : <code>mot = 0x 3C41;</code> résultat <code>6</code></li>
<li>décimal : <code>mot = 1025;</code> résultat <code>2 // le compilateur converti en binaire, pas en BCD.</code></li>
</ul>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex3-4-1">Corrigé</a> !</p>

<h2 id="ex3.5-1clignotertoujoursplus"><em>Ex 3.5&#8211;1</em> Clignoter toujours plus</h2>

<p>On vient de voir une boucle <code>for</code> pour clignoter un certain nombre de fois. Écrivez une fonction qui permettra d’écrire dans le programme :</p>

<pre><code>ClignoterNfois (nombre de fois);
</code></pre>

<p>Utiliser cette fonction dans un programme qui clignote une fois, deux fois, etc. et s’arrête à <em>5</em> fois.</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex3-5-1">Corrigé</a> !</p>

<h2 id="ex3.5-2clignoterdavantageenaccélérant"><em>Ex 3.5&#8211;2</em> Clignoter davantage en accélérant</h2>

<p>Cette fonction a un 2e paramètre qui est la vitesse. Testez avec un programme qui à la fois augmente le nombre de clignotements et la fréquence, avec une durée de salve constante. On voit donc le produit de la période par le nombre d’impulsions est constant.</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex3-5-2">Corrigé</a> !</p>

<h2 id="ex3.5-3mesurerunedurée"><em>Ex 3.5&#8211;3</em> Mesurer une durée</h2>

<p>On veut une fonction qui mesure la durée pendant laquelle on presse sur un poussoir. La durée sera en unités de 50 ms, mais on essayera des valeurs plus faibles jusqu’à être perturbé par les rebonds de contact. Pour tester, écrire le programme qui allume la LED 1 si on est très rapide, et la LED 2 si on est lent.</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex3-5-3">Corrigé</a> !</p>

<h1 id="semaine4">Semaine 4</h1>

<p>Voici les fichiers <em>LearnCbot</em> de la semaine :</p>

<ul>
<li>pour <em>Arduino</em> : <a href="http://www.didel.com/coursera/LC4.pdf">LC4.pdf</a></li>
<li>pour <em>Energia/MSP430</em> : <a href="http://pyr.ch/coursera/LC4-msp.pdf">LC4-msp.pdf</a></li>
</ul>

<p>Les programmes correspondants sont disponibles sous forme de fichier zip :</p>

<ul>
<li>pour <em>Arduino</em> : <a href="http://www.didel.com/coursera/LC4ino.zip">LC4ino.zip</a></li>
<li>pour <em>Energia/MSP430</em> : <a href="http://pyr.ch/coursera/LC4msp.zip">LC4msp.zip</a></li>
</ul>

<p>Voici également des exercices de la session 2013, qui pourront aussi vous aider à préparer les devoirs et l’évaluation :</p>

<h2 id="ex4.1-1cadrelumineuxd’uneenseigne"><em>Ex 4.1&#8211;1</em> Cadre lumineux d’une enseigne</h2>

<p>Une enseigne publicitaire est entourée d’un cadre réalisé avec des segments lumineux, selon le croquis suivant :</p>

<figure>
<img src="images/CadreEnseigne.png" alt="CadreEnseigne" />
<figcaption>CadreEnseigne</figcaption>
</figure>

<p>On cherche à donner une impression de rotation, en allumant successivement les groupes de segments suivants :</p>

<pre><code>- S0, S1, S3, S4, S6, S7, etc. (011011011011)
- S1, S2, S4, S5, S7, S8, etc. (110110110110)
- S0, S2, S3, S5, S6, S8, etc. (101101101101)
</code></pre>

<p>On dispose d’une procédure <code>AfficheCadre (unsigned int segments)</code> qui affiche les segments <em>S0</em> à <em>S11</em> selon les bits <em>0</em> à <em>11</em> du paramètre “segments” et d’une procédure <code>AttenteMs (int ms)</code>.</p>

<p>Écrivez la boucle principale du programme qui fait “tourner” le cadre dix fois dans un sens, puis dix fois dans l’autre sens.</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex4-1-1">Corrigé</a> !</p>

<h2 id="ex4.2-2détectiondesortieparl’entréed’unsupermarché"><em>Ex 4.2&#8211;2</em> Détection de sortie par l’entrée d’un supermarché</h2>

<p>Afin de lutter contre le vol à l’étalage, la direction d’un supermarché souhaite contrôler que les clients n’utilisent pas l’entrée pour sortir du magasin.</p>

<p>Deux barrières lumineuses vont être installées au niveau de l’entrée, à la même hauteur, distantes l’une de l’autre de 5 cm. Lorsqu’un client entre, la première barrière est coupée, puis la seconde. Si un client passe dans l’autre sens, ce sera le contraire. Un microcontrôleur reçoit les signaux de ces deux capteurs.</p>

<p>Écrivez le programme pour commander le contact d’un avertisseur sonore durant 5 s lorsqu’un client sort du magasin par l’entrée.</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex4-2-2">Corrigé</a> !</p>

<h2 id="ex4.3-1automatesimple"><em>Ex 4.3&#8211;1</em> Automate simple</h2>

<p>On a construit une machine avec un moteur et un contact qui se ferme à chaque tour. En pressant sur un bouton on veut que la machine fasse un tour et s’arrête. Vous voulez voir une jolie application ? <a href="http://www.bricobot.ch/kits/Miaou.pdf">http://www.bricobot.ch/kits/Miaou.pdf</a></p>

<p>Pour tester le programme, on utilise Pous1 pour démarrer, LED 1 pour dire que le moteur tourne et Pous2 comme fin de course.</p>

<figure>
<img src="images/Miaou1.png" alt="Miaou1" />
<figcaption>Miaou1</figcaption>
</figure>

<p>Le diagramme des temps montre les états possibles. Il faut tenir compte du fait que le signal Start peut durer plus longtemps que l’action, et le fin de course peut encore être activé après l’arrêt du moteur. Le programme est plus simple si on enlève ces conditions, mais ce n’est que de 2 instructions!</p>

<figure>
<img src="images/Miaou2.png" alt="Miaou2" />
<figcaption>Miaou2</figcaption>
</figure>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex4-3-1">Corrigé</a> !</p>

<h2 id="ex4.3-2commanded’unmonte-charge"><em>Ex 4.3&#8211;2</em> Commande d’un monte-charge</h2>

<p>La cabine d’un monte-charge entre deux étages est actionnée par un moteur, dont la commande dispose des entrées <code>Monte</code> et <code>Descend</code>.</p>

<p>Deux interrupteurs de fin de course <code>FinHaut</code> et <code>FinBas</code> détectent les positions des étages.</p>

<p>Deux poussoirs <code>AppelHaut</code> et <code>AppelBas</code> permettent de faire monter et descendre la cabine.</p>

<p>Le programme qui commande le monte-charge est une machine d’état.</p>

<p>Voici une proposition de marche à suivre pour faciliter le dessin du graphe d’état :</p>

<ul>
<li>établissez la liste des entrées et des sorties</li>
<li>définissez des états pour le système</li>
<li>notez les valeurs de sortie pour chaque état</li>
<li>repérez les transitions entre les états</li>
<li>notez les conditions associées à ces transitions.</li>
</ul>

<p>Une fois le graphe d’état établi, écrivez le programme par étapes successives, en suivant les informations du graphe d’état :</p>

<ul>
<li>définissez les états (par un <code>enum</code>)</li>
<li>associez les valeurs des sorties</li>
<li>écrivez les transitions</li>
</ul>

<p>Il reste à s’occuper de l’implémentation matérielle des entrées et des sorties.</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex4-3-2">Corrigé</a> !</p>

<h2 id="ex4.4-1déélectronique"><em>Ex 4.4&#8211;1</em> Dé électronique</h2>

<p>Les 7 LEDs d’un dé sont câblées comme ci-contre pour utiliser un nombre minimum de sorties du microcontrôleur. Ces sorties sont les pins <em>0</em> à <em>4</em> du <code>PORTC</code> <em>Arduino</em> <em>(pins 14,15,16,17,18)</em> ou pour <em>MSP</em> les pins <em>0</em> à <em>4</em> de <code>P2</code>. Créer la table correspondant aux 6 états du dé et écrire le programme qui “lance le dé” toutes les secondes. Évidemment, on ne va pas définir les pins indépendamment. Dans le <code>setup</code> on dit que les bits <em>0</em> à <em>3</em> sont en sorties, et on copie les configurations de bits correspondant aux faces du dé directement sur le <em>port C</em>.</p>

<figure>
<img src="images/DeJdn.png" alt="DeJdn" />
<figcaption>DeJdn</figcaption>
</figure>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex4-4-1">Corrigé</a> !</p>

<h1 id="semaine5">Semaine 5</h1>

<p>Voici les fichiers <em>LearnCbot</em> de la semaine :</p>

<ul>
<li>pour <em>Arduino</em> : <a href="http://www.didel.com/coursera/LC5.pdf">LC5.pdf</a></li>
<li>pour <em>Energia/MSP430</em> : <a href="http://pyr.ch/coursera/LC5-msp.pdf">LC5-msp.pdf</a></li>
</ul>

<p>Les programmes correspondants sont disponibles sous forme de fichier zip :</p>

<ul>
<li>pour <em>Arduino</em> : <a href="http://www.didel.com/coursera/LC5ino.zip">LC5ino.zip</a></li>
<li>pour <em>Energia/MSP430</em> : <a href="http://pyr.ch/coursera/LC5msp.zip">LC5msp.zip</a></li>
</ul>

<p>Voici également quelques exercices de la session 2013, qui pourront aussi vous aider :</p>

<h2 id="ex5.1-1messagemorse"><em>Ex 5.1&#8211;1</em> Message Morse</h2>

<p>Vous connaissez déjà le sujet, à cause du devoir de la semaine 3 ! Allons un peu plus dans le détail.</p>

<p>L’exercice est de lire avec le terminal un caractère et de clignoter son code en Morse.</p>

<p>Chaque lettre est codée dans 8 bits, 3 bits pour le nombre de <em>ti-ta</em>, 5 bits pour le code, <em>0</em> pour <em>ti</em>, <em>1</em> pour <em>ta</em>. La figure montre quelques exemples de ce codage.</p>

<p>Voici un extrait tiré de <a href="http://en.wikipedia.org/wiki/Morse_code">Wikipedia</a></p>

<blockquote>
<p>International Morse code is composed of five elements:</p>

<ol>
<li>short mark, dot or “dit” (·) — “dot duration” is one time unit long</li>
<li>longer mark, dash or “dah” (–) — three time units long</li>
<li>inter-element gap between the dots and dashes within a character — one dot duration or one unit long</li>
<li>short gap (between letters) — three time units long</li>
<li>medium gap (between words) — seven time units long[1]
    If W is the word/min (10&#8211;20), dot period T is 1200 / W</li>
</ol>
</blockquote>

<figure>
<img src="images/morse1.png" alt="morse1" />
<figcaption>morse1</figcaption>
</figure>

<p>La période <em>T</em>, durée d’un <em>dot</em>, sert à définir les autres durées. Pour le test, limitons-nous au début du code ASCII. En morse, la lettre <em>A</em> sera naturellement en <em>0</em> dans la table. En ASCII, si on tape <em>ABC</em> avec le programme terminal, on obtient les codes <em>0x41 42 43</em> qu’il faut faire correspondre aux entrées <em>0 1 2</em> de la table :</p>

<pre><code>//              A    B    C    D    E    F    G    H
TaMorse [] = {0x42,0x81,0x85,0x61,0x20,0x84,0x63,0x80};
</code></pre>

<figure>
<img src="images/morse2.png" alt="morse2" />
<figcaption>morse2</figcaption>
</figure>

<figure>
<img src="images/morse3.png" alt="morse3" />
<figcaption>morse3</figcaption>
</figure>

<p>Le programme attend une lettre du terminal (lettre-CR, voir doc) et joue les flashs ou sons. Les espaces entre lettres et mots peuvent être ignorés.</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex5-1-1">Corrigé</a> !</p>

<h2 id="ex5.4-1lire4poussoirssuruneentréeanalogique"><em>Ex 5.4&#8211;1</em> Lire 4 poussoirs sur une entrée analogique</h2>

<p>On peut lire plusieurs poussoirs en n’utilisant qu’une entrée analogique. Plusieurs câblages sont possibles. La solution proposée pour 4 poussoirs est spécialement simple à comprendre, son inconvénient éventuel est de consommer 1 mA en permanence ( la pull-down ne consomme rien).</p>

<figure>
<img src="images/pouss4.png" alt="pouss4" />
<figcaption>pouss4</figcaption>
</figure>

<p>Évidemment, pour lire les poussoirs, faut tester les tensions&#8230;</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex5-4-1">Corrigé</a> !</p>

<h2 id="ex5.5-1affichagedenombres"><em>Ex 5.5&#8211;1</em> Affichage de nombres</h2>

<p>Si on exécute <code>Serial.print (3,BIN)</code> : le résultat est <code>11</code>. On aimerait bien voir <code>00000011</code>. C’est logique de supprimer les <em>0</em> non significatifs dans les nombres décimaux, mais pas pour le binaire et l’hexa.</p>

<p>Écrire la fonction <code>PrintBin ()</code> qui affiche le nombre binaire complet. Elle est facile à programmer: on regarde un bit après l’autre en décalant à gauche et on affiche en ASCII <em>0</em> ou <em>1</em>. Le code de <em>0</em> est <em>&#8216;0&#8217;</em>, mais le terminal travaille avec des chaînes de caractères ASCII: il faut écrire <code>Serial.print (&quot;0&quot;)</code>.</p>

<p>Programmez et testez aussi la fonction <code>PrintHex ()</code>, qui vous fera réfléchir comment convertir les chiffres 4 bits: <code>0000 ⇒ '0' 1010 ⇒ 'A'</code></p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex5-5-1">Corrigé</a> !</p>

<p>Les corrigés compatibles <em>Arduino</em> se trouvent dans <a href="http://www.didel.com/coursera/Sem5SolutionsArduino.zip">Sem5SolutionsArduino.zip</a></p>

<h1 id="semaine6">Semaine 6</h1>

<p>Voici les fichiers <em>LearnCbot</em> de la semaine :</p>

<ul>
<li>pour <em>Arduino</em> : <a href="http://www.didel.com/coursera/LC6.pdf">LC6.pdf</a></li>
<li>pour <em>Energia/MSP430</em> : <a href="http://pyr.ch/coursera/LC6-msp.pdf">LC6-msp.pdf</a></li>
</ul>

<p>Les programmes correspondants sont disponibles sous forme de fichier zip :</p>

<ul>
<li>pour <em>Arduino</em> : <a href="http://www.didel.com/coursera/LC6ino.zip">LC6ino.zip</a></li>
<li>pour <em>Energia/MSP430</em> : <a href="http://pyr.ch/coursera/LC6msp.zip">LC6msp.zip</a></li>
</ul>

<h2 id="ex6.2-1dessinsurunafficheurmatriciel"><em>Ex 6.2&#8211;1</em> Dessin sur un afficheur matriciel</h2>

<p>Un afficheur matriciel de 16×16 LEDs est commandé par un microcontrôleur. Des procédures d’écriture de points ont été écrites :</p>

<pre><code>void SetPoint (int x; int y)
void ClearPoint (int x; int y)
</code></pre>

<p>Les coordonnées <em>x</em> et <em>y</em> varient de <em>0</em> à <em>15</em>. Le point <em>(0, 0)</em> est en haut à gauche de l’afficheur.</p>

<p>On dispose aussi d’une procédure <code>void Affiche (int duree)</code> qui rafraîchit l’affichage, dont la durée est multiple de 10 ms.</p>

<p>Écrivez un programme qui affiche de manière “dynamique” la lettre Z, un peu comme Zorro le fait avec son épée !</p>

<p>Une vidéo montre l’effet désiré : <a href="http://pyr.ch/coursera/exemple-aff.mp4">exemple-aff.mp4</a></p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex6-2-1">Corrigé</a> !</p>

<p><strong>Vous pouvez même tester votre programme :</strong> Un afficheur programmable à distance vous est proposé dans la page des devoirs de programmation.</p>

<h2 id="ex6.2-2affichagedeschangementsdejoueur"><em>Ex 6.2&#8211;2</em> Affichage des changements de joueur</h2>

<p>Pour le championnat interuniversitaire de football, les étudiants d’une école d’ingénieurs décident de fabriquer un panneau pour indiquer les changements de joueurs. Les étudiants en génie mécanique ont réalisé une maquette qui se présente de la manière suivante :</p>

<figure>
<img src="images/foot-change.jpg" alt="foot-change" />
<figcaption>foot-change</figcaption>
</figure>

<p>Des LEDs rouges et vertes de 5 mm de diamètre sont utilisées. Deux paires de boutons-poussoirs permettent de choisir les numéros des joueurs qui entrent et qui sortent.</p>

<p>Les étudiants en génie électrique sont chargés de réaliser la commande électronique. Les LEDs Rouges choisies ont une tension de <em>2 V</em>, les vertes <em>3 V</em>. Les deux modèles ont un courant nominal de <em>10 mA</em>.</p>

<p>Proposez un schéma pour réaliser la commande de ce panneau.</p>

<p>Choisissez un microcontrôleur et l’électronique nécessaire pour commander les 4 fois 7 segments de 28 LEDs chacun.</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex6-2-2">Corrigé</a> !</p>

<h2 id="ex6.3-1routinesspi"><em>Ex 6.3&#8211;1</em> Routines SPI</h2>

<p>Le but ce cet exercice est de comparer trois approches pour transférer 16 bits dans un registre à décalage commandant 16 LEDs.</p>

<p>Pour la première solution, utilisez la primitive <code>shiftOut</code> d’<em>Arduino</em>, abondamment documentée sur internet. Il faudra appeler 2 fois <code>shiftOut</code> pour un transfert 16 bits.</p>

<p>Exécutez le transfert 1000 fois et changez l’état de la LED 1 pour évaluer le temps d’exécution. Notez la taille du code généré.</p>

<p>Pour la 2e solution, utilisez la librairie SPI qui passe par le registre SPI interne du microcontrôleur. Il faut utiliser les pins <em>SPI</em>. <a href="http://arduino.cc/en/Reference/SPI">Référence SPI</a></p>

<p>Pour la 3e solution, utilisez les instructions <em>C</em> <code>(bitSet, bit Clear);</code> le choix de pins n’a pas d’importance, vous pouvez utiliser les mêmes que dans l’exemple <em>Arduino</em>. Notez aussi la taille mémoire et le temps d’exécution.</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex6-3-1">Corrigé</a> !</p>

<h2 id="ex6.5-1systèmesurbatteries"><em>Ex 6.5&#8211;1</em> Système sur batteries</h2>

<p>Pour essayer d’effrayer les taupes qui faisaient des ravages dans son jardin potager, un jardinier a installé un dispositif qui émet des bruits de manière pseudo-aléatoire, par courtes séquences. En moyenne, le dispositif est actif au total 90 s chaque heure. La consommation en mode actif est de 40 mA. Le microcontrôleur consomme lui-même 1 mA en permanence, en fonctionnant à 1 MHz. Les deux piles 1.5 V AA utilisées ont une capacité de 1300 mAh.</p>

<p>Calculez la durée de vie d’un jeu de piles. Proposez des solutions pour que le système consomme globalement moins de courant, en vue de lui donner une meilleure autonomie.</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex6-5-1">Corrigé</a> !</p>

<h1 id="semaine7">Semaine 7</h1>

<p>Voici les fichiers <em>LearnCbot</em> de la semaine :</p>

<ul>
<li>pour <em>Arduino</em> : <a href="http://www.didel.com/coursera/LC7.pdf">LC7.pdf</a></li>
<li>pour <em>Energia/MSP430</em> : <a href="http://pyr.ch/coursera/LC7-msp.pdf">LC7-msp.pdf</a></li>
</ul>

<p>Les programmes correspondants sont disponibles sous forme de fichier zip :</p>

<ul>
<li>pour <em>Arduino</em> : <a href="http://www.didel.com/coursera/LC7ino.zip">LC7ino.zip</a></li>
<li>pour <em>Energia/MSP430</em> : <a href="http://pyr.ch/coursera/LC7msp.zip">LC7msp.zip</a></li>
</ul>

<h2 id="ex7.2-1servos"><em>Ex 7.2&#8211;1</em> Servos</h2>

<p>Pour un robot à patte, on teste le mouvement des deux servos. La jambe doit d’abord faire un angle de 60° en 1 s. Puis la cuisse et la jambe se déplacent de 60° en 1 s pour être alignés. Les servos couvrent un angle de 120° pour des impulsions entre 1 et 2 ms distantes de 20 ms. Les servos sont documentés 120° (pour 1 à 2 ms), et 60° en 0.1 s.</p>

<p>Comment ralentir le mouvement ? Rappelez-vous que l’on envoie la consigne de position toutes les 20 ms. Les servos tournent dans le sens horaire si l’impulsion est plus longue. La position initiale correspond à 1 ms.</p>

<figure>
<img src="images/LEGSERVO.GIF" alt="LEGSERVO" />
<figcaption>LEGSERVO</figcaption>
</figure>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex7-2-1">Corrigé</a> !</p>

<h2 id="ex7.3-1d’ouvientlalumière "><em>Ex 7.3&#8211;1</em> D’ou vient la lumière ?</h2>

<p>Deux photorésistances (LDR) sont câblées en diviseur de tension. La tension du point milieu envoyé sur A0 dépend de la différence d’éclairage sur les deux LDR, quelque soit l’intensité lumineuse. On éclaire avec une lampe de poche, et on veut que les LEDs Led1 et Led2 indiquent d’où vient la lumière.</p>

<p>Réfléchissez à la variation de tension en A0 avant de programmer. Utilisez le terminal pour observer les valeurs lues.</p>

<figure>
<img src="images/SUIVMOO.GIF" alt="SUIVMOO" />
<figcaption>SUIVMOO</figcaption>
</figure>

<figure>
<img src="images/Ex731.jpg" alt="Ex731" />
<figcaption>Ex731</figcaption>
</figure>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex7-3-1">Corrigé</a> !</p>

<h2 id="ex7.4-1filtragedemesures"><em>Ex 7.4&#8211;1</em> Filtrage de mesures</h2>

<p>Les microcontrôleurs sont beaucoup utilisés dans des systèmes de mesure et d’acquisition de données. Très souvent, un traitement des mesures doit être effectué. Le “traitement numérique du signal” (Digital Signal Processing) est un sujet très vaste, qui fait appel à des techniques mathématiques adaptées. Un excellent MOOC est proposé par l’EPFL à ce sujet.</p>

<p>Beaucoup plus simplement, nous allons ici réaliser un filtre de type “hystérésis”. Une LDR (photorésistance) mesure la luminosité ambiante. La technique de mesure de la résistance par mesure du temps de décharge d’un condensateur peut être utilisée. On souhaite réaliser un “interrupteur crépusculaire” : une lampe doit être allumée la nuit et éteinte le jour. Voici un exemple de mesure obtenue à l’aube :</p>

<figure>
<img src="images/courbe-ldr.png" alt="courbe-ldr" />
<figcaption>courbe-ldr</figcaption>
</figure>

<p>Avec le programme suivant, on applique simplement un seuil (indiqué en pointillé) :</p>

<pre><code>#define Seuil 70
int mesure;
while (1) {
  mesure = MesureLum();
  if (mesure &lt; Seuil) {
    AllumeLampe;
  } else {
    EteintLampe;
  }
}
</code></pre>

<p>On voit que la lampe risque de ne pas s’éteindre (ou s’allumer) d’un seul coup (courbe bleue). On cherche à obtenir plutôt la courbe verte : 5 valeurs successives doivent dépasser le “seuil haut” pour que la mesure soit vue comme “haute”. Le même mécanisme sera appliqué avec un “seuil bas”.</p>

<p>Modifiez le programme en conséquence !</p>

<p>Cherchez par vous-même la réponse. Ensuite, vous pourrez voir le <a href="https://class.coursera.org/microcontroleurs-004/wiki/view?page=corr-ex7-4-1">Corrigé</a> !</p>

<div style="page-break-before:right;"></div>

<h1 id="semaine1">Semaine 1</h1>

<h2 id="corr1.2-1détecteurdegel"><em>Corr 1.2&#8211;1</em> Détecteur de gel</h2>

<p>La thermistance prend une valeur de 3.1 kΩ à 1°C. Pour que la tension de base soit égale à 0.7 V, la tension aux bornes de la thermistance est de 5 V - 0.7 V = 4.3 V. Le courant dans la thermistance est donc de I = U / R = 4.3 V / 3.1 kΩ = 1.39 mA.</p>

<p>Le courant dans la thermistance est le même que dans la résistance R (si le courant de base est négligeable).</p>

<p>Aux bornes de la résistance R, on a une tension de 0.7 V (c’est la tension de base). Pour que le courant soit de 1.39 mA, elle doit être de R = U / I = 0.7 V / 1.39 mA = 503 Ω, donc environ 500 Ω. Il faudra ajuster cette valeur pour avoir une détection précise : on utilisera une résistance variable (par exemple de 100 Ω) en série avec une résistance fixe (par exemple de 470 Ω).</p>

<h2 id="corr1.3-1logiqueàtransistors"><em>Corr 1.3&#8211;1</em> Logique à transistors</h2>

<p>Chaque transistor va conduire quand l’entrée correspondante est à <em>1</em>. Tant qu’aucun des transistors ne conduit, aucun courant ne peut circuler. La sortie est alors à <em>1</em>, à cause de la résistance et de la LED sur les collecteurs, reliés au plus.</p>

<p>Quand un des deux transistors conduit (ou les deux), la sortie passe à <em>0</em>. On a donc une porte NOR.</p>

<p>Équation logique : A + B</p>

<p>Mais attention : la LED s’allume quand la sortie est à <em>0</em>. Elle montre donc l’inverse de la sortie (fonction OU).</p>

<h2 id="corr1.4-1schémaduou-exclusif"><em>Corr 1.4&#8211;1</em> Schéma du OU-exclusif</h2>

<p>Il est pratique de commencer par écrire l’équation logique à partir de la table de vérité :</p>

<p>S = A ⋅ B + A ⋅ B</p>

<p>Voici le schéma correspondant :</p>

<figure>
<img src="images/log-xor-detail.png" alt="log-xor-detail" />
<figcaption>log-xor-detail</figcaption>
</figure>

<p>La porte de droite est bien une porte NAND (par le théorème de De Morgan)</p>

<p>A ⋅ B = A + B</p>

<h2 id="corr1.4-2diagrammetemporel"><em>Corr 1.4&#8211;2</em> Diagramme temporel</h2>

<p>Il est facile de remplir les cases de la table de vérité en suivant le diagramme temporel</p>

<figure>
<img src="images/diagramme-temp-corr.png" alt="diagramme-temp-corr" />
<figcaption>diagramme-temp-corr</figcaption>
</figure>

<p>Mais on finit par voir qu’il manque un cas !</p>

<p>Le diagramme des temps n’est généralement pas un bon moyen de représenter un système combinatoire. Mais il est très utile pour étudier les systèmes séquentiels.</p>

<h2 id="corr1.5-1machined’état"><em>Corr 1.5&#8211;1</em> Machine d’état</h2>

<p>Il faut commencer par déterminer les entrées et les sorties du système, puis dessiner un graphe d’état :</p>

<figure>
<img src="images/compteur-5.png" alt="compteur-5" />
<figcaption>compteur&#8211;5</figcaption>
</figure>

<p>Le système va changer d’état à chaque coup d’horloge. L’état suivant dépend de l’entrée de comptage-décomptage, qu’on a appelée <em>Plus</em>. Il a 5 états. Il faut donc au moins 3 bascules pour mémoriser les états. Le système combinatoire qui va donner les nouvelles valeur aux entrées des bascules aura donc 4 entrées : l’entrée <em>Plus</em> et les 3 sorties des bascules, qui représentent l’état courant.</p>

<figure>
<img src="images/compteur-5-schema.png" alt="compteur-5-schema" />
<figcaption>compteur&#8211;5-schema</figcaption>
</figure>

<p>Remplissons la table de vérité, en donnant pour chaque ligne l’état futur (valeur de comptage) en fonction de la valeur courante et du mode de comptage. Écrivons ensuite les équations.</p>

<figure>
<img src="images/compteur-5-table.png" alt="compteur-5-table" />
<figcaption>compteur&#8211;5-table</figcaption>
</figure>

<p>C’est bien compliqué ! Il faudrait encore simplifier, en appliquant les propriétés de l’algèbre de Boole aux équations ou en utilisant les tables de Karnaugh.</p>

<p>Ce sera peut-être plus simple de programmer un microcontrôleur&#8230;</p>

<h2 id="corr1.6-1conversiondécimal-binaire"><em>Corr 1.6&#8211;1</em> Conversion décimal-binaire</h2>

<p>On se souvient des puissances de <em>2 : 1 2 4 8 16 32 64 128 256 512 1024 2048 4096&#8230;</em></p>

<p>On peut par exemple soustraire successivement les puissances de <em>2</em> qu’il est possible de soustraire au nombre.</p>

<p><em>5 = 4<em>1 + 2</em>0 + 1*1 = 4 + 1 = 0b101</em></p>

<p><em>12 = 8 + 4 = 0b1100</em></p>

<p><em>63 = 32 + 16 + 8 + 4 + 2 + 1 =&gt; 0b111111</em></p>

<p>Autre moyen de calculer :</p>

<p><em>63 = 64 - 1 = 0b1000000 - 1 = 0b111111</em></p>

<p><em>257 = 256 + 1 = 0b100000001</em></p>

<p><em>1280 = 1024 + 256 = 0b10100000000</em></p>

<h2 id="corr1.6-2conversionbinaire-hexadécimal"><em>Corr 1.6&#8211;2</em> Conversion binaire-Hexadécimal</h2>

<p>Il faut commencer par couper le nombre binaire en tranches de 4 bits, depuis la droite, puis utiliser la table de conversion :</p>

<p><em>0000 = 0, 0001 = 1, 0010 = 2, 0011 = 3, 0100 = 4, 0101 = 5, 0110 = 6, 0111 = 7</em></p>

<p><em>1000 = 8, 1001 = 9, 1010 = A, 1011 = B, 1100 = C, 1101 = D, 1110 = E, 1111 = F</em></p>

<p><em>0b01011111 = 0b0101&#8217;1111 = 0x5F</em></p>

<p><em>0b00110111 = 0b0011&#8217;0111 = 0x37</em></p>

<p><em>0b1110010011011001 = 0b1110&#8217;0100&#8217;1101&#8217;1001 = 0xE4D9</em></p>

<p><em>0b101111001 = 0b1&#8217;0111&#8217;1001 = 0x179</em></p>

<h2 id="corr1.6-3conversionbcd-décimal"><em>Corr 1.6&#8211;3</em> Conversion BCD-décimal</h2>

<p>Il faut couper le nombre binaire en tranches de 4 bits, depuis la droite, puis utiliser ta table de conversion :</p>

<p><em>0000 = 0, 0001 = 1, 0010 = 2, 0011 = 3, 0100 = 4, 0101 = 5, 0110 = 6, 0111 = 7, 1000 = 8, 1001 = 9</em></p>

<p><em>0010001101011001 = 0010&#8217;0011&#8217;0101&#8217;1001 = 2359</em> (par exemple 23h59 pour représenter une heure)</p>

<p>Par contre <em>1110010011011001</em> n’est pas un nombre BCD ! (la valeur <em>1110</em> n’a pas de correspondant dans la table).</p>

<h1 id="semaine2">Semaine 2</h1>

<h2 id="corr2.2-1microprocesseuretmicrocontrôleur"><em>Corr 2.2&#8211;1</em> Microprocesseur et microcontrôleur</h2>

<p>Mes étudiants me posent souvent la question&#8230;</p>

<p>Un microcontrôleur contient un microprocesseur ! Mais il contient aussi de la mémoire (ROM, RAM) et des circuits d’entrée-sortie, pour être un à lui seul un système informatique autonome.</p>

<h2 id="corr2.3-1microcontrôleurs8-16-32 bits"><em>Corr 2.3&#8211;1</em> Microcontrôleurs 8&#8211;16&#8211;32 bits</h2>

<p>Même un processeur 8 bits est capable d’effectuer des calculs sur des nombres de 32 bits. Il faut alors décomposer les opérations en opérations sur des nombres de 8 bits, un peu comme nous avons appris à l’école à effectuer des additions, des soustractions, des multiplications et des divisons ! Mais rassurez-vous : c’est le compilateur qui va faire ce travail, pas vous&#8230;</p>

<p>Il faudra peut-être des dizaines ou même des centaines d’opérations élémentaires sur 8 bits pour effectuer un calcul. Mais ce n’est pas grave : rappelez-vous que même le petit processeur contenu dans un microcontrôleur &#8220;entrée de gamme&#8221; est généralement capable d’exécuter des millions d’instructions par seconde !</p>

<h2 id="corr2.3-2fréquenceetpuissancedecalcul"><em>Corr 2.3&#8211;2</em> Fréquence et puissance de calcul</h2>

<p>Il faut être très prudent en comparant des microcontrôleurs (et les processeurs qu’ils contiennent). La fréquence est certainement une indication des performances, mais d’autres facteurs sont aussi très importants :</p>

<ul>
<li>la largeur du bus de données (processeur 8 bits – 16 bits – 32 bits)</li>
<li>le nombre de coups d’horloge nécessaire pour l’exécution de chaque instruction</li>
<li>la richesse du jeu d’instructions</li>
<li>l’organisation des mécanismes d’interruption</li>
<li>les performances de l’unité arithmétique</li>
<li>etc.</li>
</ul>

<h2 id="corr2.4-1programmationencarduino :clignoterpendantquel’onpresse"><em>Corr 2.4&#8211;1</em> Programmation en <em>C/Arduino</em> : clignoter pendant que l’on presse</h2>

<p>Voici une solution :</p>

<pre><code>//Solution241.ino
#define Pous 2 // pin2 Arduino
#define PousOn digitalRead (Pous) == 0
#define PousOff digitalRead (Pous) == 1
#define Led 5
#define LedOn digitalWrite (Led,LOW) ;
#define LedOff digitalWrite (Led,HIGH) ;
void setup () {
  pinMode (Pous, INPUT) ;
  pinMode (Led,OUTPUT) ;
}
void loop () {
  if (PousOn) {
    LedOn ; delay (250);
    LedOff ; delay (250);
  }
}
</code></pre>

<p>Variante en ajoutant dans la définition de LedToggle (réagit plus rapidement quand on relâche, pressez rapidement pour voir la différence) :</p>

<pre><code>void loop () {
  if (PousOn) {
    LedToggle ; delay (250);
  }
}
</code></pre>

<h2 id="corr2.4-2programmationencarduino :allumer2 squandonpresse"><em>Corr 2.4&#8211;2</em> Programmation en <em>C/Arduino</em> : allumer 2 s quand on presse</h2>

<p>Voici une solution :</p>

<pre><code>//Solution242.ino
#define Pous 2
#define PousOn digitalRead (Pous) == 0
#define PousOff digitalRead (Pous) == 1
#define Led 5
#define LedOn digitalWrite (Led,LOW) ;
#define LedOff digitalWrite (Led,HIGH) ;
void setup () {
  pinMode (Pous, INPUT) ;
  pinMode (Led,OUTPUT) ;
}
void loop () {
  if (PousOn) {
    LedOn ; delay (2000);
    LedOff ; // tester un délai
             // ici delay (1000);
  }
  while (PousOn) {}
}
</code></pre>

<h2 id="corr2.4-3programmationencarduino :unpoussoirpour2leds"><em>Corr 2.4&#8211;3</em> Programmation en <em>C/Arduino</em> : Un poussoir pour 2 LEDs</h2>

<p>Voici une solution :</p>

<pre><code>//Solution243.ino
#define Led1 5 //Actif à 0 MSP Energia pin xx
#define Led2 6
#define Led1Toggle digitalWrite \
  (Led1, !digitalRead (Led1))
#define Led2Toggle digitalWrite \
  (Led2, !digitalRead (Led2))
#define Pous 2 // actif à 0
#define PousOn !digitalRead(Pous)
void setup() {
  pinMode (Pous,INPUT);
  pinMode (Led1,OUTPUT);
  pinMode (Led2,OUTPUT);
}
void loop () {
  while (PousOn) {delay (20);}
  while (!PousOn){delay (20);}
  Led1Toggle;
  if (digitalRead (Led1)) {
    Led2Toggle;
  }
}
</code></pre>

<p>On remarque que l’on a programmé un compteur par 4. Les LEDs s’allument dans la séquence <code>00 01 10 11</code></p>

<p>À noter aussi que <code>if (digitalRead (Led1) == 1)</code> peut s’écrire <code>if (digitalRead (Led1))</code></p>

<h2 id="corr2.4-4programmationencarduino :deuxpoussoirpouruneleds"><em>Corr 2.4&#8211;4</em> Programmation en <em>C/Arduino</em> : Deux poussoir pour une LEDs</h2>

<p>Voici une solution :</p>

<pre><code>//Solution244.ino
#define Pous1 2
#define Pous2 3
#define Pous1On !digitalRead (Pous1)
#define Pous2On !digitalRead (Pous2)
#define Led 5
#define LedOn digitalWrite (Led,LOW) ;
#define LedOff digitalWrite (Led,HIGH) ;
void setup () {
  pinMode (Pous1, INPUT) ;
  pinMode (Pous2, INPUT) ;
  pinMode (Led,OUTPUT) ;
}
void loop () {
  if (Pous1On) { LedOn ; delay (20); }
  if (Pous2On) { LedOff ; delay (20); }
}
</code></pre>

<p>Que se passe-t-il si on presse les deux poussoirs ? et quand on relâche ?</p>

<h2 id="corr2.5-1programmationd’uncompteurupdown"><em>Corr 2.5&#8211;1</em> Programmation d’un compteur up/down</h2>

<p>Voici une solution :</p>

<pre><code>// UpDown.ino
#define Led1 5 // actif à 0
#define Pous1 2 // actif à 0
#define Pous2 3 // actif à 0
#define Pous1On !digitalRead (Pous1) // actif
                                     // à 0
#define Pous2On !digitalRead (Pous2) // actif
                                     // à 0
#define Led1On digitalWrite (Led1, LOW)
#define Led1Off digitalWrite (Led1, HIGH)
void setup() {
  pinMode (Led1, OUTPUT);
  pinMode (Pous1, INPUT);
  pinMode (Pous2, INPUT);
}
byte compteur = 6;
void loop() {
  if (Pous1On) {
    if (compteur &lt; 7) {
      compteur ++;
      if (compteur &amp; 0x01) Led1On ;
      else Led1Off ;
      delay (200);
    }
  }
  if (Pous2On) {
    if (compteur &gt;0) {
      compteur --;
      if (compteur &amp; 0x01) Led1On ;
      else Led1Off ;
      delay (200);
    }
  }
}
</code></pre>

<h2 id="corr2.5-2estimationdeladuréedelafonctionarduinomap"><em>Corr 2.5&#8211;2</em> Estimation de la durée de la fonction <em>Arduino</em> <code>Map ()</code></h2>

<p>Voici une solution :</p>

<pre><code>// DureeMap
#define Led1 5 // Actif à 0
#define Led1Toggle \
  digitalWrite (Led1, !digitalRead (Led1))
void setup() {
  pinMode (Led1,OUTPUT);
}
int cnt, y;
void loop () {
  cnt = 0;
  while (cnt++ &lt; 10000) {
    y = map (500,240,680,32,35) ;
  }
  Led1Toggle;
}
</code></pre>

<h1 id="semaine3">Semaine 3</h1>

<h2 id="corr3.1-1variablesetarithmétiques"><em>Corr 3.1&#8211;1</em> Variables et arithmétiques</h2>

<p>Il faut se souvenir du cercle des nombres Modulos !</p>

<ol>
<li><code>x + y = 8 + 3 = 11</code></li>
<li><code>y + z = 3 + 250 = 253</code></li>
<li><code>x + z = 8 + 250 = 258</code> Mais 258 ne peut pas être représenté par 8 bits. La réponse est <code>258 % 256 = 2</code> (opération Modulo)</li>
<li><code>y - x = 3 - 8 = -5</code> Mais un byte ne représente que des nombres positifs ! La réponse est <code>-5 + 256 = 251</code></li>
<li><code>x / y = 8 / 3 = 2</code> Le reste de la division entière est “perdu” !</li>
<li><code>y / x = 3 / 8 = 0</code></li>
<li><code>z / y = 250 / 3 = 83</code></li>
<li><code>z % y = 250 % 3 = 1</code> En effet, <code>83 * 3 = 249</code>, le reste de la division est donc <code>1</code>.</li>
</ol>

<h2 id="corr3.1-2autremanièred’écrirelabouclefor"><em>Corr 3.1&#8211;2</em> Autre manière d’écrire la boucle <code>for</code></h2>

<pre><code>byte i=0;
while (i&lt;10) {
  instructions;
  i++;
}
</code></pre>

<h2 id="corr3.1-3utilisationdel’instructionbreak"><em>Corr 3.1&#8211;3</em> Utilisation de l’instruction <code>break</code></h2>

<p>Notre solution est de remettre le compteur à <em>0</em> quand on presse et tester une limite de comptage pour sortir du `while(1).</p>

<pre><code>// Solution313.ino
byte cnt=0;
while (1) {
  if (Pous1On) {cnt=0;}
  delay (50);
  if (cnt &gt;= 100) { break; }
  cnt++;
}
Led1On; delay (500);
Led1Off; delay (500);
</code></pre>

<p>Pourquoi la valeur 100 ? Voici le calcul : 5 s = 5000 ms, la boucle <code>while</code> se fait toutes les 50 ms, donc 5000 / 50 = 100. Vous voulez tester une autre durée ? Il faut recalculer. Ce n’est pas la bonne façon de faire. La donnée du problème doit être décrite au début du programme et la boucle du programme ne doit pas dépendre de valeurs numériques, mais de valeurs fonctionnelles.</p>

<p>Le programme bien écrit est donc</p>

<pre><code>// Solution313b.ino
#define AttenteMax 5000 // 5 secondes
#define PeriodeEchant 50
byte cnt=0;
while (1) {
  if (Pous1On) { cnt=0; }
  delay (PeriodeEchant) ;
  if (cnt &gt;= AttenteMax/PeriodeEchant)
  { break; }
  cnt++;
}
Led1On; delay (500);
Led1Off; delay (500);
</code></pre>

<p>Si vous voulez changer l’attente, c’est un changement de données initiales et non pas un changement de programme qui sera nécessaire ! Si vous relisez ces deux programmes dans un mois, le premier vous demandera du temps pour comprendre votre idée, alors que le second s’explique de lui-même.</p>

<p>Notez que ces exemples ne sont pas les meilleurs pour illustrer l’instruction <code>break</code>. En effet, il aurait été facile de modifier un peu le programme pour que le <code>break</code> soit placé comme dernière instruction du bloc. Dans ce cas, la manière la plus naturelle serait d’utiliser la structure <code>do...while</code> !</p>

<h2 id="corr3.2-1testdetouslesportsd’unmicrocontrôleur"><em>Corr 3.2&#8211;1</em> Test de tous les ports d’un microcontrôleur</h2>

<p>Pour un AVR :</p>

<pre><code>// Solution321.ino
void setup() {
  DDRD |= 0xFC; // ne pas modifier les pins
                // 0 et 1
                // (ligne série de l’Arduino)
  DDRC = 0x3F; // tout en sortie
  DDRB = 0xFF;
}
void loop() {
  PORTD = 0x55 ; // ou 0b01010101, bits pairs
  PORTB = 0x55 ;
  PORTC = 0x55 ;
  delay(300);
  PORTD = 0xAA ; // ou 10101010, bits impairs
  PORTB = 0xAA ;
  PORTC = 0xAA ;
  delay(300);
}
</code></pre>

<p>Pour un MSP430G :</p>

<pre><code>// Solution321.ino
void setup() {
  P1DIR = 0xFF; // tout en sortie
  P2DIR = 0xFF; // tout en sortie
  P2SEL = 0; // si on veut que P2.6 et P2.7
             // soient aussi des
             // entrées-sorties
}
void loop() {
  P1OUT = 0x55 ; // ou 0b01010101, bits pairs
  P2OUT = 0x55 ;
  delay(300);
  P1OUT = 0xAA ; // ou 10101010, bits impairs
  P2OUT = 0xAA ;
  delay(300);
}
</code></pre>

<h2 id="corr3.2-2charlieplexing"><em>Corr 3.2&#8211;2</em> <em>Charlieplexing</em></h2>

<pre><code>DDRB =  0b00000101;
PORTB = 0b00000001;
</code></pre>

<p>Explication : <code>P0</code> et <code>P2</code> sont en sortie, <code>PB1</code> est en entrée (pour être à haute impédance, sans agir sur le montage) <code>PB0</code> à <em>1</em> (le + sur l’anode de la LED 5) et <code>PB2</code> est à <em>0</em> (le - sur la cathode de la LED 5)</p>

<h2 id="corr3.3-1champsdebits"><em>Corr 3.3&#8211;1</em> Champs de bits</h2>

<p>Une solution est de mettre successivement les deux bits à <em>1</em> avec le “set bit” :</p>

<pre><code>DDRC |= (1&lt;&lt;0);
DDRC |= (1&lt;&lt;6);
</code></pre>

<p>Il faut regarder s’il est nécessaire que les autres bits soient à <em>0</em>. Ajouter dans ce cas :</p>

<pre><code>DDRC = 0;
</code></pre>

<p>Cette instruction n’est pas nécessaire au début d’un programme sur un <em>AVR</em> : tous les registres sont mis à <em>0</em> au moment du <em>Reset</em> (qu’il soit d’origine interne ou externe au microcontrôleur).
Une solution qui semble plus compacte serait :</p>

<pre><code>DDRC |= (1&lt;&lt;0)|(1&lt;&lt;6);
</code></pre>

<p>Elle a l’avantage que les deux bits sont mis à <em>1</em> au même moment dans le registre.</p>

<p>Mais en observant ce que le compilateur produit, dans le cas particulier de l’<em>AVR</em>, la première solution est la moins gourmande en mémoire : les <code>set bits</code> sont détectés par le compilateur et n’utilisent d’une instruction machine !</p>

<h2 id="corr3.4-1combiende1 "><em>Corr 3.4&#8211;1</em> Combien de 1 ?</h2>

<pre><code>// Solution342.ino
int nombre = 1025;
// 1025 décimal = 1024 + 1 = 10000000001
// donc 2 &quot;1&quot;
// int nombre = 0b0000100001001100 ; // 4 &quot;1&quot;
// int nombre = 0x3C41 ;
// en binaire 0011 1100 0100 0001
// Le programme compte les 1 dans le mot
// binaire qui a été converti à partir du
// décimal ou de l’hexa pour le mettre
// en mémoire.
byte cnt = 0;
void loop () {
  for (int i=0; i&lt;16; i++) {
    if (nombre &amp;1) {
      // test bit 0, identique
      // à if (mot &amp;1&lt;&lt;0)
      cnt++;
    }
  nombre &gt;&gt;= 1; // on décale
  }
  if (cnt &gt; 0) { // on clignote n fois
    for (int i=0; i&lt;cnt; i++){
      Led1On; delay (300);
      Led1Off; delay (300);
    }
  }else { Led2On; }
}
</code></pre>

<h2 id="corr3.5-1clignotertoujoursplus"><em>Corr 3.5&#8211;1</em> Clignoter toujours plus</h2>

<p>La fonction a un paramètre en entrée. Les variables locales n’ont pas besoin d’avoir un nom explicite. C’est mieux de bien les distinguer des variables globales par des noms courts.</p>

<p>Le programme utilise une boucle <code>for</code>. On pourrait aussi utiliser un <code>while</code>.</p>

<p>En <em>C</em>, les fonctions doivent précéder le programme principal (la procédure <code>main</code>).</p>

<p>L’environnement <em>Arduino</em> est tolérant et semble permettre de déclarer une fonction après l’avoir utilisée.</p>

<pre><code>Solution351.ino :
// Fonctions ClignoterNfois (nombre de fois);
void ClignoterNfois (byte nn) {
  for (int i=0; i&lt;nn; i++) {
    Led1On; delay (300);
    Led1Off; delay (300);
  }
}
void loop () {
  for (int i=0; i&lt;5; i++) {
    ClignoterNfois (i) ;
    delay (500);
  }
  delay (2000);
}
</code></pre>

<h2 id="corr3.5-2clignoterdavantageenaccélérant"><em>Corr 3.5&#8211;2</em> Clignoter davantage en accélérant</h2>

<p>Solution352.ino</p>

<pre><code>// Fonctions
// ClignoterNfoisPer (nombre de fois, periode);
void ClignoterNfoisPer (byte nn, int pp) {
  for (int i=0; i&lt;nn; i++) {
    Led1On; delay (pp/2);
    Led1Off; delay (pp/2);
  }
}
// Le programme clignote toujours plus vite
// pendant la même durée
byte count ;
int periode;
void loop () {
  count++ ;
  periode = 1000/count;
  ClignoterNfoisPer (count,periode) ;
  delay (200); // supprimer pour voir
}
</code></pre>

<h2 id="corr3.5-3mesurerunedurée"><em>Corr 3.5&#8211;3</em> Mesurer une durée</h2>

<p>Solution353.ino</p>

<pre><code>// fonction MesureDureePous1On ()
byte MesureDureePous1On () {
  byte cnt; // pour le paramètre à rendre
  while (!Pous1On) { delay (50); }
  cnt=0;
  while (Pous1On) {
    delay (50); cnt++;
  }
  return cnt;
}
// on estime le min à 0.2s et le max à 1s
byte MinDuree = 200/50;
byte MaxDuree = 1000/50;
byte duree;
void loop () {
  duree = MesureDureePous1On ();
  // on est bloqué dans cette ligne
  // tant que l’on n’a pas pressé!
  if (duree &lt; MinDuree) Led1On;
  if (duree &gt; MaxDuree) Led2On;
  delay (2000);
  Led1Off; Led2Off; // et on recommence
}
</code></pre>

<h1 id="semaine4">Semaine 4</h1>

<h2 id="corr4.1-1cadrelumineuxd’uneenseigne"><em>Corr 4.1&#8211;1</em> Cadre lumineux d’une enseigne</h2>

<p>Les motifs successifs à envoyer ont été placés dans un tableau. Un index parcourt le tableau dans un sens ou dans l’autre, selon la variable <code>sens</code>. Les changements de direction se font donc en repartant de la position courante, pour un effet visuel optimal.</p>

<pre><code>// nombre de mouvements dans le cycle
#define MaxCycle 10
// attente ente chaque changement
#define Periode 200

// nombre de motifs dans la table
#define LgTable 3
unsigned int tableMotifs[] =
  {0b011011011011, 0b110110110110,
  0b101101101101};
// index dans la table
unsigned char idx=0;
// sens de balayage de la table
unsigned char sens=1;
// compteur des répétitions
unsigned char cycle;

void loop() {
 for(cycle=0;cycle&lt;(MaxCycle*LgTable);cycle++)
  {
    if (sens) {
      if (idx == (LgTable-1))
      { idx=0;}
      else { idx++;}
    }
    else {
      if (idx == 0)
      { idx=LgTable-1; }
      else { idx--;}
    }
    AfficheCadre (tableMotifs[idx]);
    AttenteMs (Periode);
  }
  sens = !sens;
}
</code></pre>

<h2 id="corr4.2-2détectiondesortieparl’entréed’unsupermarché"><em>Corr 4.2&#8211;2</em> Détection de sortie par l’entrée d’un supermarché</h2>

<p>On peut utiliser la technique pour détecter un flanc montant (barrière lumineuse coupée) sur la seconde barrière. Si elle se produit quand la première barrière n’est pas coupée, c’est qu’une personne cherche à sortir du supermarché par l’entrée.</p>

<pre><code>unsigned char etatBarriere1;
unsigned char etatBarriere2;
unsigned char ancienetatBarriere1 = Barriere1;
unsigned char ancienEtatBarriere2 = Barriere2;

void loop() {
  etatBarriere1 = Barriere1;
  etatBarriere2 = Barriere2;
  if (etatBarriere2 &amp;&amp; !ancienEtatBarriere2)
  { // flanc montant sur la seconde barrière
    if (!etatBarriere1)
    { // détection d’une sortie
      AlarmeOn; delay (5000); AlarmeOff;
    }
  }
  ancienetatBarriere1 = etatBarriere1;
  ancienEtatBarriere2 = etatBarriere2; }
}
</code></pre>

<h2 id="corr4.3-1automatesimple"><em>Corr 4.3&#8211;1</em> Automate simple</h2>

<pre><code>//Solution431.ino Automate simple
#include &quot;LcDef.h&quot;
#define StartOn Pous1On
#define FinCourseOn Pous2On
#define MoteurOn Led1On
#define MoteurOff Led1Off

void setup() {
  LcSetup () ;
}

void loop () {
  while (!StartOn) {} // on attend le start
  MoteurOn;
  // si le fin de course touche encore
  while (FinCourseOn) {}
  while (!FinCourseOn) {} // ca tourne
  MoteurOff;
  // si le start est toujours actif
  while (StartOn) {}
}
</code></pre>

<h2 id="corr4.3-2commanded’unmonte-charge"><em>Corr 4.3&#8211;2</em> Commande d’un monte-charge</h2>

<p>Le système a 4 entrées : <code>AppelHaut</code> et <code>AppelBas</code> pour les poussoirs de commande, <code>Haut</code> et <code>Bas</code> pour les fins de courses. Il a 2 sorties : <code>Monte</code> et <code>Descend</code>, pour la commande du moteur.</p>

<p>Voici un graphe d’état possible :</p>

<figure>
<img src="images/GrapheMonteCharge.png" alt="GrapheMonteCharge" />
<figcaption>GrapheMonteCharge</figcaption>
</figure>

<p>Les deux valeurs notées dans chaque état correspondent aux sorties <code>Monte</code> et <code>Descend</code>.</p>

<p>Il ne faut pas faire monter la cabine si elle est déjà en haut : c’est ce qui justifie la condition <code>(AppelHaut . /Haut)</code> pour la transition entre <code>Repos</code> et <code>Montee</code>.</p>

<p>Note : le point indique le ET logique (notation mathématique en algèbre de Boole).</p>

<p>La notation <code>/Haut</code> signifie que <code>Haut</code> est inversé. On la trouve souvent dans la documentation.</p>

<p>Dans le programme, les états sont identifiés par un <code>enum</code> et mémorisés dans une variable d’état :</p>

<pre><code>enum {Repos, Montee, Descente};
unsigned char Etat;
</code></pre>

<p>La boucle principale comporte une structure switch avec un `case pour chaque état. Les sorties sont assignées selon chaque état. Les transitions modifient l’état courant selon la condition associée :</p>

<pre><code>void loop () {
  switch (Etat) {
  case Repos :
    Stop;
    if (!Haut &amp;&amp; AppelHaut) Etat = Montee;
    if (!Bas &amp;&amp; AppelBas) Etat = Descente;
     break;
  case Montee :
    Monte;
    if (Haut) Etat = Repos;
    break;
  case Descente :
    Descend;
    if (Bas) Etat = Repos;
    break;
  }
}
</code></pre>

<p>Voici comment définir les entrées-sorties, en utilisant le fichier DefP2L2.def :</p>

<pre><code>// Définitions propres au monte charge :
// - action sur les sorties :
#define Stop {Led1Off; Led2Off;}
#define Monte {Led1On; Led2Off;}
#define Descend {Led1Off; Led2On;}
// - lecture des entrées :
#define AppelHaut Pous1On
#define AppelBas Pous2On
</code></pre>

<p>Il faut encore ajouter deux entrées supplémentaires. Voici la version _MSP430_ :</p>

<pre><code>#define FinHaut !(P1IN &amp; (1&lt;&lt;5))
#define FinBas !(P1IN &amp; (1&lt;&lt;7))
</code></pre>

<p>&#8230; et la version <em>AVR</em> (<em>Arduino</em>) :</p>

<pre><code>#define FinHaut !(PINB &amp; (1&lt;&lt;0))
#define FinBas !(PINB &amp; (1&lt;&lt;1))
</code></pre>

<p>Les solutions complètes avec les procédure <code>setup()</code> se trouvent dans Solution431.ino.</p>

<p>Dans Solution431C.ino, vous trouverez les versions écrites intégralement en <em>C</em>, sans utiliser les <code>setup()</code> et <code>loop()</code>.</p>

<h2 id="corr4.4-1déélectronique"><em>Corr 4.4&#8211;1</em> Dé électronique</h2>

<pre><code>//Solution441.ino
// PortC 0-3 pour allumer le dé selon schéma
// 2   3
// 1 0 1
// 3   2

void setup() {
  DDRC = 0b0001111; // sorties
}

byte motifsDe [6] = {
  0b0001,0b0100,0b1001,0b1100,0b1101,0b1110};

void loop () {
  int i=random (0,6); // min à max-1
  PORTC = ~motifsDe [i] ;
  delay (1000);
  PORTC = ~0b0000;
  delay (200);
}
</code></pre>

<p>Deux instructions du programme principal devraient vous choquer. Que fait ce <code>PORTC</code> dans un programme principal, qui devient dépendant du matériel ? L’opération est de copier un motif sur un port. Quel port, dire qu’il faut inverser les informations logiques pour créer le bon signal électrique n’a rien à faire ici! On doit fabriquer une fonction qui exprime ces contraintes technologiques.</p>

<pre><code>void CopyMotif (mm) {
  PORTC = ~mm ;
}
</code></pre>

<p>Dans le programme, on voit alors des instructions explicites</p>

<pre><code>CopyMotif (motifsDe [i]) et CopyMotif (0);
</code></pre>

<h1 id="semaine5">Semaine 5</h1>

<h2 id="corr5.1-1messagemorse"><em>Corr 5.1&#8211;1</em> Message Morse</h2>

<p>On peut écrire ce programme de plusieurs façons différentes. L’important est de bien le structurer, bien séparer les définitions de l’interface lumineuse/sonore et de l’application.</p>

<pre><code>//Solution512.ino Messages Morses - Test A..H
#include &quot;DefC2p2l.h&quot;
// Format Bits 7 6 5 Letter length
// 4 3 2 1 0 dot/dash msb first
// Table Ascii a b c ..h
// codes ascii 61 62 .. 67
byte TaMorse [] =
{0x42,0x81,0x85,0x61,0x20,0x84,0x63,0x80 } ;
#define DurDot 200 //200 ms 6mots/min
int dot= DurDot;

void Dot () { // point - ti
  Led1On; delay (dot);
  Led1Off; delay (dot);
}
void Dash () { // trait - ta
  Led1On; delay (dot*3);
  Led1Off; delay (dot);
}
void JoueMorse (byte cc) {
  byte dd = cc&gt;&gt;5;
  for (byte i ; i&lt;dd; i++) {
    if (cc&amp;1) { Dash(); }
    else { Dot(); }
    cc&gt;&gt;=1 ;
  }
}

void setup() {
  Setup2p2l();
  Serial.begin(9600);
  Dash(); Dot(); Dash(); // debug
}

char codeRecu;
byte indexTaMorse;
byte codeTaMorse;
void loop () {
if (Serial.available() &gt; 0) {
  codeRecu = Serial.read();
Serial.print(codeRecu,HEX);Serial.print (&quot; &quot;);
  indexTaMorse = codeRecu - 'a' ;
Serial.print(indexTaMorse);Serial.print (&quot; &quot;);
  codeTaMorse = TaMorse [indexTaMorse] ;
Serial.println (codeTaMorse,HEX);
  JoueMorse (codeTaMorse);
}
</code></pre>

<p>Vous remarquez que les instructions d’aide au dépannage sont toujours dans le programme. Il faut mettre le teminal en mode “pas de fin de ligne” pour éviter le décodage du caractère fin de ligne.</p>

<p>On peut améliorer ce programme pour taper des mots au terminal. Tant que <code>Serial.available</code> est positif, on lit la lettre suivante en ajoutant l’espace entre lettres. Si on a tapé une phrase, il faut repérer les espaces pour ajouter l’espace entre mots.</p>

<p>Si vous avez un haut-parleur, il suffit de réécrire les fonctions <code>Dot()</code> et <code>Dash()</code>.</p>

<h2 id="corr5.4-1lire4poussoirssuruneentréeanalogique"><em>Corr 5.4&#8211;1</em> Lire 4 poussoirs sur une entrée analogique</h2>

<p>Voilà une solution, vous en avez probablement inventé une autre qui fonctionne.</p>

<pre><code>//Solution541.ino
// Valeurs estimées -- a vérifier
#define Nopous 0 ;
#define Vpous1 205 // 1V
#define Vpous2 410 // 2V
#define Vpous3 614 // 3V
#define Vpous4 819 // 4V

void setup() {
  Serial.begin(9600);
  // pas nécessaire de déclare A0 en entrée
}

int valPous ;
void loop () {
  valPous = analogRead (A0) ;
  numeroPous=0;
  if (valPous &gt; Vpous1 -50) numeroPous=1;
  if (valPous &gt; Vpous2 -50) numeroPous=2;
  if (valPous &gt; Vpous3 -50) numeroPous=3;
  if (valPous &gt; Vpous4 -50) numeroPous=4;
  if (valPous &gt; Vpous1 -50) {
    Serial.print (numeroPous);
    while (valPous &lt; Vpous1 -50) {}
  }
}
</code></pre>

<p><strong>Une solution élégante</strong></p>

<p>La fonction <code>map</code> d’<em>Arduino</em> est très efficace pour cette application. On définit 4 zones entre 0.5 et 4.5 V et en une seule instruction on obtient les valeurs <code>1,2,3,4</code> que l’on peut utiliser dans un <code>switch..case</code>.</p>

<pre><code>byte numereoPous = map (AnalogRead(14),102,921,1,4)
</code></pre>

<p>C’est intéressant de comparer la taille des codes et les temps d’exécution.</p>

<p>Solution avec if : &#8230;&#8230;..</p>

<p>SolutionMap : &#8230;&#8230;..</p>

<h2 id="corr5.5-1affichagedenombres"><em>Corr 5.5&#8211;1</em> Affichage de nombres</h2>

<pre><code>//Solution551.ino
void setup() {
Serial.begin(9600);
}
void PrintBin (byte bb) {
  for (byte i=0;i&lt;8;i++) {
  if (bb&amp;0x80) Serial.print (&quot;1&quot;);
  else Serial.print (&quot;0&quot;);
  bb &lt;&lt;= 1;
  }
}

void loop () {
  PrintBin (17);
  while (1) {}
}
</code></pre>

<p>Pour le <code>PrintHex</code>, 2 fonctions sont préférables.</p>

<pre><code>char ConvNibble (byte nn)
{ // converti 4 bits hexa en Ascii
  char cc;
  if (nn&lt;10) cc = nn + '0';
  else cc = nn-10 + 'A';
  return cc;
}
void PrintHex (byte hh) {
 char cc;
 cc = ConvNibble(hh &gt;&gt; 4);//ne modifie pas hh
 Serial.print (cc);
 cc = ConvNibble (hh &amp; 0x0F) ;
 Serial.print (cc);
 Serial.print (&quot; &quot;);//cela évite un séparateur
}
</code></pre>

<p>On peut avoir besoin d’un <code>PrintHexInt</code>, <code>PrintHexLong</code> et on comprend pourquoi supprimer les <em>0</em> non significatifs permet d’avoir une fonction d’impression qui accepte tous les types.</p>

<p>Une solution est de définir un <code>PrintHex</code> avec 2 paramètres, le nombre, dans un type quelconque, et le nombre de chiffres à afficher. Il suffit d’ajouter une boucle <code>for</code> dans <code>PrintHex</code> !</p>

<h1 id="semaine6">Semaine 6</h1>

<h2 id="corr6.2-1dessinsurunafficheurmatriciel"><em>Corr 6.2&#8211;1</em> Dessin sur un afficheur matriciel</h2>

<p>La routine comporte 3 boucles itératives <code>for</code>. Deux variables <code>x</code> et <code>y</code> sont utilisées pour les deux coordonnées.</p>

<pre><code>//Solution 6.2-1
#define MaxX 16
#define MaxY 16

void Zoro () {
  int x; int y;
  for (x=0; x&lt;MaxX; x++)
  {//gauche-droite en haut
    SetPoint (x, 0);
    Affiche (5);
  }
  Affiche (20); // petite attente
  y=0;
  for (x=MaxX-1; x&gt;=0; x--)
  { // diagonale droite-gauche
    SetPoint (x, y);
    y++;
    Affiche (5);
  }
  Affiche (20);
  for (x=0; x&lt;MaxX; x++)
  { // gauche-droite en bas
    SetPoint (x, MaxY-1);
    Affiche (5);
  }
  Affiche (1000); // attente une seconde
  }
}
</code></pre>

<p>Il serait possible d’écrire des procédures plus générales, permettant de tracer des segments de différents types, ou même des droites quelconques.</p>

<p>Notez que si l’afficheur est balayé, il est impossible d’utiliser un délai habituel pour programmer une attente : l’affichage serait vide durant ce temps ! Il faut appeler la procédure de rafraîchissement de la matrice.</p>

<h2 id="corr6.2-2affichagedeschangementsdejoueur"><em>Corr 6.2&#8211;2</em> Affichage des changements de joueur</h2>

<p>Le système a 4 entrées (les poussoirs pour choisir les numéros) et 28 sorties (6 fois 7 segments). Attention, ne confondez pas de nombre de 28 avec les 28 LEDs sur chaque segment: on voit sur le dessin qu’un segment est composé de trois rangées de 9, 10 et 9 LEDs.</p>

<p>On trouve des microcontrôleurs avec un nombre suffisant de pattes pour ce projet. En boîtiers DIL 40 pattes, <em>Atmel</em> en propose (par exemple l’<em>ATmega32</em> ou ses successeurs). <em>Microchip</em> propose aussi des <em>PIC</em> avec ce type de boîtiers (comme le <em>16F877</em>). Mais ces processeurs sont “relativement” coûteux. Ils disposent aussi de “trop” de mémoire pour un si petit projet. Vous me direz que “qui peut le plus peut le moins”, c’est vrai&#8230;</p>

<p>La solution utilisant des registres série-parallèle est intéressante pour ce projet. En ajoutant 4 circuits <em>74HC595</em>, il n’y a besoin plus que de 4 entrées et 3 sorties. Avec l’astuce des 4 poussoirs sur une entrée analogique, les “fans” des microcontrôleurs à 8 pattes pourraient s’en sortir, par exemple avec un <em>ATtiny13</em>. Dans la série des <em>MSP430G</em>, le <em>2231</em> à 14 pattes conviendrait très bien.</p>

<p>L’autre problème est la commande des 28 LEDs de chaque segment. Avant de choisir le montage, il faut choisir la tension d’alimentation ! Le choix de 12 V permet d’utiliser facilement :</p>

<ul>
<li>des piles 1.5 V (8 piles, au format AA, ou C ou D)</li>
<li>des batteries NiMH 1.2 V (10 batteries, au format AA, ou C ou D)</li>
<li>une batterie au plomb 12 V (batterie de moto par exemple)</li>
</ul>

<p>Ensuite, il faut déterminer l’architecture : 5 LEDs rouges peuvent être mises en parallèle (2 × 2 V = 10 V), mais seulement 3 LEDs vertes (3 × 3 = 9 V). On voit qu’on aura donc 5 branches de 5 LEDs rouges, plus une branche de 3 LEDs. Pour les vertes, on aura 9 branches de 3 LEDs, plus une branche avec une seule LED. C’est donc pour les LEDs vertes que le courant sera le plus important : 10 × 10 mA. Un simple transistor NPN va donc convenir (<em>2N3904</em>, <em>BC337</em>, etc.)</p>

<figure>
<img src="images/change-foot-schema.png" alt="change-foot-schema" />
<figcaption>change-foot-schema</figcaption>
</figure>

<p>Il reste le choix des résistances. D’abord des calculs pour estimer les valeurs :</p>

<ul>
<li>La résistance pour les branches de 5 LEDs rouges : (12V - (5 * 2V)) / 10mA = 2/10 kΩ = 200 Ω</li>
<li>La résistance pour la branche de 3 LEDs rouges : (12V - (3*2V)) / 10mA = 6/10 kΩ = 600 Ω</li>
<li>La résistance pour les branches de 3 LEDs vertes : (12V - (3 * 3V)) / 10mA = 3/10 kΩ = 300 Ω</li>
<li>La résistance pour la branche d’une LED verte : (12V - 3V) / 10mA = 9/10 kΩ = 900 Ω</li>
</ul>

<p>Mais seule l’expérimentation avec les LEDs choisies donnera les bonnes valeurs ! D’abord, les valeurs des tensions des LEDs (2 V et 3 V) ne sont pas exactes. Mais il y a plus important : le rendement des LEDs rouges et vertes n’est pas identique. On va donc ajuster l’intensité lumineuse pour que les deux parties de l’afficheur donne une impression visuelle semblable.</p>

<h2 id="corr6.3-1routinesspi"><em>Corr 6.3&#8211;1</em> Routines SPI</h2>

<pre><code>//Solution631shiftOut 360us 1108 octets
#include &quot;DefC2p2l.h&quot;
#define Ld 10 // SPI SS
#define Ck 13
#define Mosi 11

void setup() {
  Setup2p2l ();
  pinMode (Ld,OUTPUT);
  pinMode (Ck,OUTPUT);
  pinMode (Mosi,OUTPUT);
}

int data=0x1234;
void loop () {
  for (long i=0; i&lt;10000;i++) {
   digitalWrite(Ld, 0);
   shiftOut (Mosi,Ck,LSBFIRST,lowByte(data));
   shiftOut (Mosi,Ck,LSBFIRST,highByte(data));
   digitalWrite(Ld, 1);
  }
  Led1Toggle;
}
</code></pre>

<p></p>

<pre><code>//Solution631SPI 17us 1074 octets
// les 2 digitalWrite font perdre 6 us
#include &quot;DefC2p2l.h&quot;
#define Ld 10 // SPI SS
#define Ck 13
#define Mosi 11
#include &quot;SPI.h&quot;

void setup() {
  Setup2p2l ();
  pinMode (Ld,OUTPUT);
  pinMode (Ck,OUTPUT);
  pinMode (Mosi,OUTPUT);
  SPI.begin();
  SPI.setBitOrder(LSBFIRST);
}

int data=0x1234;
void loop () {
  for (long i=0; i&lt;100000;i++) {
    digitalWrite(Ld, 0);
    SPI.transfer(lowByte (data));
    SPI.transfer(highByte (data));
    digitalWrite(Ld, 1);
  }
  Led1Toggle;
}
</code></pre>

<p></p>

<pre><code>//Solution631Cdirect 18us 576 octets
#include &quot;DefC2p2l.h&quot;
#define bLd 2 // portB pin10
#define bCk 5 // portB pin13
#define bMosi 3 // portB pin11

void setup() {
  Setup2p2l ();
  DDRB |= 1&lt;}

int data=0x1234;
void loop () {
  data=0x1234;
  for (long i=0; i&lt;100000;i++) {
    bitClear (PORTB,bLd);
    for (int i=0;i&lt;16;i++) {
      if (data &amp; 0x01) bitSet (PORTB,bMosi);
      else bitClear (PORTB,bMosi) ;
      bitSet (PORTB,bCk);
      data &gt;&gt;= 1; // décale et détruit data
      bitClear (PORTB,bCk); // durée 0.25 us
      data &gt;&gt;= 1; // détruit data
      bitClear (PORTB,bLd);
    } // end shif
  } // end repeat
  Led1Toggle;
} // end loop
</code></pre>

<h2 id="corr6.5-1systèmesurbatteries"><em>Corr 6.5&#8211;1</em> Système sur batteries</h2>

<p>Chaque heure, le microcontrôleur va prendre à lui seul <em>1 mA × 1 h = 1 mAh</em> dans la batterie. Le mode actif va prendre <em>40 mA × 1 h × (90 s / 1 h) = 1 mAh</em>. On a donc un courant “moyen” de <em>2 mA</em>. La durée de vie d’un jeu de piles sera donc d’environ <em>1300 mAh / 2 mA = 650 h</em>, soit moins d’un mois.</p>

<p>Il est intéressant de diminuer la consommation du microcontrôleur, vu qu’elle participe à la moitié de la consommation moyenne. On pourrait limiter un peu le courant consommé par le processeur en diminuant sa fréquence. Diminuer la tension semble difficile dans ce cas. La solution la plus efficace est clairement de mettre le processeur en mode “sleep”, comme expliqué dans le document <a href="http://pyr.ch/coursera/FaibleConsoDoc.pdf">FaibleConsoDoc.pdf</a>.</p>

<p>La consommation dans ce mode où le processeur n’exécute aucune instruction est extrêmement faible, de l’ordre du µA. Il faudra alors utiliser un Timer et une interruption pour “réveiller” le processeur.</p>

<h1 id="semaine7">Semaine 7</h1>

<h2 id="corr7.2-1servos"><em>Corr 7.2&#8211;1</em> Servos</h2>

<p>En 1 s, il y a 50 mises à jour de la position du servo. L’angle 60° correspond à la moitié de la course, donc 0.5 ms.</p>

<p>L’augmentation d’angle se donne en microsecondes.</p>

<pre><code>//Solution721.ino
#include &quot;DefC2p2l.h&quot;  // pas utilisé
#define Femur 10 // pin
#define Tibia 11
#define PosInitiale 1000  // 1ms
#define Angle60 500 // us
#define TempsDepl 1000 //  (1s)
#define NbreDePas TempsDepl/20

int augmAngle = Angle60/(NbreDePas); //500/50
int angleFemur;  // 1000 à 2000 us
int angleTibia;

void PulseServoFemur (int aa) {
   digitalWrite (Femur,1);
   delayMicroseconds (aa);
   digitalWrite (Femur,0);
}
void PulseServoTibia (int aa) {
   digitalWrite (Tibia,1);
   delayMicroseconds (aa);
   digitalWrite (Tibia,0);
}
// les deux impulsions se suivent dans chaque
// cycle de 20ms il faut ajouter un délai de
// 20000-angleFemur-angleTibia une fonction
// FinTrame20ms serait un bonne pratique.

void setup()  {
  Setup2p2l ();
  pinMode (Femur,1);
  pinMode (Tibia,1);
}

void loop () {
  for (int i=0; i&lt;NbreDePas; i++) {
    angleFemur = PosInitiale+(i*augmAngle);
    PulseServoFemur (angleFemur);
    angleTibia = PosInitiale;
    PulseServoTibia (angleTibia);
    delay (15);   // probl en dessus de 17000
    delayMicroseconds \
      (5000-angleFemur-angleTibia);
//delayMicroseconds \
//(20000-angleFemur-angleTibia); //--&gt; 4 ms!!
  }
  for (int i=0; i&lt;NbreDePas; i++) {
      angleFemur = \
        PosInitiale+Angle60-(i*augmAngle);
      PulseServoFemur (angleFemur);
      angleTibia = PosInitiale+(i*augmAngle);
      PulseServoTibia (angleTibia);
      delay (15);
      delayMicroseconds \
        (5000-angleFemur-angleTibia);
  }
//  while (1) {} // ou retour en arrière
}
</code></pre>

<p>Il y a eu un problème de mise au point ! J’avais écrit :</p>

<pre><code>#define NbreDePas TempsDepl/20;
int augmAngle = Angle60/NbreDePas;
</code></pre>

<p>Le préprocesseur a envoyé au compilateur après substitution du <code>#define</code> :</p>

<pre><code>int augmAngle = Angle60/TempsDepl/20;
</code></pre>

<p>Le compilateur applique la règle de précédence des parenthèses :</p>

<pre><code>int augmAngle = (Angle60/TempsDepl)/20;
</code></pre>

<p>Le résultat est toujours <em>0</em> ici !
Le programme a été corrigé en écrivant :</p>

<pre><code>int augmAngle = Angle60/(NbreDePas);
</code></pre>

<h2 id="ex7.3-1d’ouvientlalumière "><em>Ex 7.3&#8211;1</em> D’ou vient la lumière ?</h2>

<pre><code>//Solution731.ino  D'ou vient la lumière
#define LedDroite 5
#define LedGauche 6
#include &quot;DefC2p2l.h&quot;  // pas utilisé
// Pin 13 A0 entrée analogique
void setup()   {
  Setup2p2l();
  Serial.begin (9600);
  PORTC=0;
}
// variables globales
int difference;
#define Centre 120   // lu par A0 au centre
int intensiteLedD ;
int intensiteLedG ;

void loop () {
  // Résultat 0-255
  difference = (analogRead (A0))/4;

  Serial.print (difference);
  Serial.print (&quot;  &quot;);
  intensiteLedD = (difference-Centre)*4 ;
  if (intensiteLedD &gt; 255) intensiteLedD=255;
  if (intensiteLedD &lt; 0) intensiteLedD=0;
  intensiteLedG = (Centre-difference)*4 ;
  if (intensiteLedG &gt; 255) intensiteLedG=255;
  if (intensiteLedG &lt; 0) intensiteLedG=0;
//if(difference&lt;Centre-(LargeZoneCentre/2)) {
//if(difference&gt;(Centre+(LargeZoneCentre/2)))
//{  // plus a droite
  Serial.print (&quot; D &quot;);
  Serial.print (intensiteLedD);
  Serial.print (&quot; G &quot;);
  Serial.println (intensiteLedG);
  analogWrite (LedDroite, intensiteLedD) ;
  analogWrite (LedGauche, intensiteLedG) ;
}
</code></pre>

<p>Pouvez-vous ajouter une zone morte au centre ?</p>

<p>Vous voyez comment utiliser les deux poussoirs pour choisir entre un affichage analogique ou digital ?</p>

<h2 id="ex7.4-1filtragedemesures"><em>Ex 7.4&#8211;1</em> Filtrage de mesures</h2>

<pre><code>//limite des valeurs considérées &quot;hautes&quot;
#define SeuilHaut 90
//limite des valeurs considérées &quot;basses&quot;
#define SeuilBas 50
// nombre de mesures &quot;hautes&quot; ou &quot;basses&quot;
// nécessaires pour agir sur la lampe
#define NombreMesuresSeuil 5

// variable pour la mesure de luminosité
int mesure;
// compteur des dépassements du seuil &quot;haut&quot;
int cptHaut = 0;
// compteur des dépassements du seuil &quot;bas&quot;
int cptBas = 0;

while (1) { // boucle infnie
  mesure = MesureLum();
  if (mesure &gt; SeuilHaut) {
    cptHaut++;
    if (cptHaut &gt; NombreMesuresSeuil) {
      EteintLampe;
      // évite que le compteur
      // augmente à l'infini
      cptHaut = NombreMesuresSeuil;
    }
  } else if (mesure &lt; SeuilBas) {
    cptBas++;
    if (cptBas &gt; NombreMesuresSeuil) {
      AllumeLampe;
      cptBas = NombreMesuresSeuil;
    }
  } else {
    cptHaut = 0;
    cptBas = 0;
  }
}
</code></pre>

</body>
</html>
